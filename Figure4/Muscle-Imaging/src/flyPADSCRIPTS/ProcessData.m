%{
1.Put all the files in the same folder
2. run this script
This script is designed to work with binary files generated by Bonsai`s
MatrixWriter node(sink/dsp)

!!!!! IMPORTANT!!!!!
filename has a certain structure to it, and the code is using the filename
to assign conditions to different channels
for example the file:

CapacitanceData_C01_01_24_C02_25_44_C03_45_64_2014-02-21T11_07_11.dat

starts with "CapacitanceData"(case sensitive)

followed by "_C01_01_24_C02_25_44_C03_45_64"
This is an identifier for various conditions 
in this example there are 3 conditions: C01, C02,C03
Condiotion 1(C01) is located on channels 01-24; Condition 2(C02)on channels
25-44 and Condition 3(C03) on channels 45-64.
Note there are 64 channels in total, each arena has 2 channels.

the results will be stored in Events.mat 

Events.mat has the following data:
Events.SipOns - Sip starts
Events.SipOffs - Sip ends
Events.SipDurations - Sip durations
Events.SipISI - Sip intersip intervals

Events.ActivityBoutOns - activity bout starts
Events.ActivityBoutOffs - activity bout stops
Events.ActivityBoutDurations - activity bout durations
Events.ActivityBoutIBI - activity bout inter - bout intervals

Events.FeedingBurstOns - feeding burst starts
Events.FeedingBurstOffs - feeding burst stops
Events.FeedingBurstDurs - feeding burst durations
Events.FeedingBurstnEvents  - number of sips per feeding burst
Events.FeedingBurstIBI - feeding burst inter burst intervals
%}
clear all
close all
%% This is the name of the file where the data will be stored
DataFilename='Events.mat';
%% this parameter defines the desired duration to which to clip the
%% Set the duration of the recording file in samples(Sampling rate is 100 Hz)
Dur=310000;
%% these are the labels for different conditions

Events.ConditionLabel{1}= 'Cond1 ';
Events.ConditionLabel{2}= 'Cond2';
Events.ConditionLabel{3}= 'Cond3';
%% These are the labels for substrates (what goes on channel 1 and 2)
Events.SubstrateLabel{1}='substrate 1';
Events.SubstrateLabel{2}='substrate 2';
%% This Line defines which channels(devices) should be annotated as to be removed
Remove=[ ];%% !!!!!!!!!! CheckThis line always!!!!


%% Don`t change anything below this point !!!!
DatabaseOffset=0;


%% Settings

Channels=[1 2;3 4; 5 6; 7 8; 9 10;11 12; 13 14;15 16;17 18;19 20;21 22;23 24;25 26;27 28;29 30;31 32;33 34;35 36;37 38;39 40;41 42;43 44;45 46;47 48;49 50;51 52;53 54;55 56;57 58;59 60;61 62; 63 64];
ChannelsToRemove=Channels(Remove,:);
ChannelsToRemove=ChannelsToRemove(~isnan(ChannelsToRemove));
DateOffset=4;
RMSWindow=50;
PlayFrameRate=10;
RMSThresh=10;
Window=100;% maximum duration of the bout in samples
MinWindow=4; % minimum duration of the bout in samples
EqualityFactor=0.5; % set to 50 % , meaning that the down transition should be at least 50 % the size of the up transition
ProximityWindow=MinWindow+3; % How many samples far should the transitions be
CapFilename='CapacitanceData_C01_01_24_C02_25_44_C03_45_64_2014-02-21T11_07_11.dat';
currentDir=pwd;
fileList = getAllFiles(currentDir);

numel(currentDir)

for n=1:size(fileList,1)
    
    namez=fileList{n,1};
    z(n)=numel(findstr(namez,'CapacitanceData'));
    
end




CapFilenames=fileList(logical(z));
for FileNameCounter=1:size(CapFilenames,1)
    CapFilename=CapFilenames{FileNameCounter,1};
    CapFilename=CapFilename(numel(currentDir)+1:end);
    %% Extract from the filename which channel is yeast and which is sucrose
    
    
    fileID=fopen(CapFilename);
    CapData=fread(fileID,'ushort');
    CapData=reshape(CapData,64,size(CapData,1)/64);
    
    c=0;
    test=CapData';
    test=test(1:Dur,:);
    
    %% this code defines which channels correspond to which condition
    
    nChannels=size(test,2);
    C(1,1)=str2double([CapFilename(findstr(CapFilename,'C01')+4) CapFilename(findstr(CapFilename,'C01')+5)]);
    C(1,2)=str2double([CapFilename(findstr(CapFilename,'C01')+7) CapFilename(findstr(CapFilename,'C01')+8)]);
    
    C(2,1)=str2double([CapFilename(findstr(CapFilename,'C02')+4) CapFilename(findstr(CapFilename,'C02')+5)]);
    C(2,2)=str2double([CapFilename(findstr(CapFilename,'C02')+7) CapFilename(findstr(CapFilename,'C02')+8)]);
    
    C(3,1)=str2double([CapFilename(findstr(CapFilename,'C03')+4) CapFilename(findstr(CapFilename,'C03')+5)]);
    C(3,2)=str2double([CapFilename(findstr(CapFilename,'C03')+7) CapFilename(findstr(CapFilename,'C03')+8)]);
    
    C(4,1)=str2double([CapFilename(findstr(CapFilename,'C04')+4) CapFilename(findstr(CapFilename,'C04')+5)]);
    C(4,2)=str2double([CapFilename(findstr(CapFilename,'C04')+7) CapFilename(findstr(CapFilename,'C04')+8)]);
    
    C(5,1)=str2double([CapFilename(findstr(CapFilename,'C05')+4) CapFilename(findstr(CapFilename,'C05')+5)]);
    C(5,2)=str2double([CapFilename(findstr(CapFilename,'C05')+7) CapFilename(findstr(CapFilename,'C05')+8)]);
    
    C(6,1)=str2double([CapFilename(findstr(CapFilename,'C06')+4) CapFilename(findstr(CapFilename,'C06')+5)]);
    C(6,2)=str2double([CapFilename(findstr(CapFilename,'C06')+7) CapFilename(findstr(CapFilename,'C06')+8)]);
    
    C(7,1)=str2double([CapFilename(findstr(CapFilename,'C07')+4) CapFilename(findstr(CapFilename,'C07')+5)]);
    C(7,2)=str2double([CapFilename(findstr(CapFilename,'C07')+7) CapFilename(findstr(CapFilename,'C07')+8)]);
    
    C(8,1)=str2double([CapFilename(findstr(CapFilename,'C08')+4) CapFilename(findstr(CapFilename,'C08')+5)]);
    C(8,2)=str2double([CapFilename(findstr(CapFilename,'C08')+7) CapFilename(findstr(CapFilename,'C08')+8)]);
    
    C(9,1)=str2double([CapFilename(findstr(CapFilename,'C09')+4) CapFilename(findstr(CapFilename,'C09')+5)]);
    C(9,2)=str2double([CapFilename(findstr(CapFilename,'C09')+7) CapFilename(findstr(CapFilename,'C09')+8)]);
    
    C(10,1)=str2double([CapFilename(findstr(CapFilename,'C10')+4) CapFilename(findstr(CapFilename,'C10')+5)]);
    C(10,2)=str2double([CapFilename(findstr(CapFilename,'C10')+7) CapFilename(findstr(CapFilename,'C10')+8)]);
    
    %% predefine the final data structure and fill it with Nans
    
    Events.Condition{FileNameCounter}=nan(1,64);
    for n=1:size(C,1)
        if ~isnan(C(n,:))
            Events.Condition{FileNameCounter}(C(n,1):C(n,2))=n;
        end
    end
    
    Events.Yeast{FileNameCounter}=zeros(1,64);
    Events.Yeast{FileNameCounter}(1:2:64)=1;
    Events.Sucrose{FileNameCounter}=zeros(1,64);
    Events.Sucrose{FileNameCounter}(2:2:64)=1;
    Events.Substrate{FileNameCounter}=zeros(1,64);
    Events.Substrate{FileNameCounter}(1:2:64)=1;
    Events.Substrate{FileNameCounter}(2:2:64)=2;
    
    ToRemove=Channels(Remove,:);
    Events.ToRemove{FileNameCounter}=zeros(1,64);
    Events.ToRemove{FileNameCounter}(sort(ToRemove(~isnan(ToRemove))))=1;
    
    
    Events.ChannelsToRemove{FileNameCounter+DatabaseOffset}=ChannelsToRemove;
    
    Events.Date{FileNameCounter+DatabaseOffset,1}=CapFilename(findstr(CapFilename,'201'):findstr(CapFilename,'201')+9);
    time=CapFilename(findstr(CapFilename,'201')+11:end);
    time([3 6])=':';
    Events.Time{FileNameCounter+DatabaseOffset,1}=time;
    %% Filtering
    
    filteredTraces=nan(size(test));
    for i = 1:1:size(test,2)
        c=c+1 %#ok<NOPTS>
        Ch1=test(:,i);
        span=50;
        window = ones(span,1)/span;
        filteredTraces(:,i) = convn(Ch1,window,'same');
    end
    RfilteredTraces=test-filteredTraces;
    %% remove the edges
    RfilteredTraces([1:span end-span:end],:)=0;
    test([1:span end-span:end],:)=0;
    %% get the RMS
    testRMS= fastrms(RfilteredTraces,RMSWindow,1,0);
    RRfilteredTraces=RfilteredTraces(2:end,:);
    TimeStamps=(1:size(RRfilteredTraces,1))./100;
    FDerivative=diff(RfilteredTraces);
    
    %% use Quiroga`s method to find the signal
    clear thrPos thrNeg PosEvents NegEvents
    
    %% Dyn Thresholding of the derivative of the capacitance trace to find candidate onsets and offsets of sips
    Window_For_Threshold=300;
    for n=1:size(FDerivative,2);
        
        FDerivativePos=FDerivative(:,n);
        FDerivativeNeg=FDerivative(:,n);
        c=1;
        Count=0;
        for m=1:Window_For_Threshold:size(FDerivative,1)-Window_For_Threshold
            c=c+Window_For_Threshold;
            Count=Count+1;
            Fpos=FDerivativePos(m:c);
            Fneg=FDerivativeNeg(m:c);
            thrPos{n,Count}=4.*median(Fpos(Fpos>1))./0.6745;
            
            thrNeg{n,Count}=4.*median(Fneg(Fneg<-1))./0.6745;
            
            PosEvents(n,m:c)=FDerivative(m:c,n)>thrPos{n,Count};
            NegEvents(n,m:c)=FDerivative(m:c,n)<thrNeg{n,Count};
            
            
        end
    end
    RRfilteredTraces=RfilteredTraces(2:end,:);
    TimeStamps=(1:size(RRfilteredTraces,1))./100;
    
    %% Assign zeros to all signals that are not defined as events
    FFDerivative=zeros(size(FDerivative));
    derivativeForFigure=FDerivative;
    
    clear NE PE
    for n=1:size(NegEvents,1)
        
        NE=logical(NegEvents(n,:))';
        PE=logical(PosEvents(n,:))';
        Derivative2=FDerivative(:,n);
        Derivative1=FDerivative(:,n);
        Derivative2(:,:)=0;
        Derivative2(NE)=Derivative1(NE);
        Derivative2(PE)=Derivative1(PE);
        FFDerivative(:,n)=Derivative2;
    end
    
    FDerivative=FFDerivative;
    
    ChosenOnes=false(size(NegEvents));
    ChosenOnes=ChosenOnes';
    %% finding events which are not local maxima
    for nChanels=1:size(RRfilteredTraces,2)
        if sum(abs(FDerivative(:,nChanels)))>10
            disp(nChanels)
            [~,locsPos]=findpeaks(FDerivative(:,nChanels),'minpeakdistance',ProximityWindow);
            [~,locsNeg]=findpeaks(-1.*FDerivative(:,nChanels),'minpeakdistance',ProximityWindow);
            ChosenOnes(locsPos,nChanels)=true;
            ChosenOnes(locsNeg,nChanels)=true;
        else
        end
    end
    
    
    PPosEvents=PosEvents&ChosenOnes';
    NNegEvents=NegEvents&ChosenOnes';
        
    for n=1:size(NNegEvents,1)
        
        NE=NNegEvents(n,:)';
        PE=PPosEvents(n,:)';
        Derivative2=FDerivative(:,n);
        Derivative1=FDerivative(:,n);
        Derivative2(:,:)=0;
        Derivative2(NE)=Derivative1(NE);
        Derivative2(PE)=Derivative1(PE);
        FFDerivative(:,n)=Derivative2;
    end
    
    FDerivative=FDerivative(1:max(size(PosEvents)),:);
    RRfilteredTraces=RRfilteredTraces(1:max(size(PosEvents)),:);
    RfilteredTraces=RfilteredTraces(1:max(size(PosEvents)),:);
    TimeStamps=TimeStamps(:,1:max(size(PosEvents)));
    test=test(1:max(size(PosEvents)),:);
    %% Final step of the sip detection algorythm
    for nChannels=1:size(test,2)
        clear trace PosEvents NegEvents EventCounter CurrentIndexUp
        clear EventDuration indNeg indPos
        
        trace=FFDerivative(:,nChannels);
        PosEvents=find(PPosEvents(nChannels,:));
        NegEvents=find(NNegEvents(nChannels,:));
        EventCounter=0;
        disp(nChannels)
        if numel(PosEvents)>=2
            CurrentIndexUp=PosEvents(1);
            
            while CurrentIndexUp<size(trace,1)
                offset=CurrentIndexUp;
                
                % if the window doesnt go out of the range and if there is an event in the window
                if (CurrentIndexUp+Window < numel(trace))
                    
                    % if there are negative events in window
                    if find(NegEvents>CurrentIndexUp  & NegEvents<CurrentIndexUp+Window)
                        
                        % If there are negative events of the right size
                        if  find(trace(CurrentIndexUp:CurrentIndexUp+Window)<=(trace(CurrentIndexUp)*-EqualityFactor),1,'first')>=MinWindow;
                            EventCounter=EventCounter+1;
                            indNeg(EventCounter)=find(trace(CurrentIndexUp:CurrentIndexUp+Window)<=(trace(CurrentIndexUp)*-EqualityFactor),1,'first')+offset-1;
                            indPos(EventCounter)=CurrentIndexUp;
                            EventDuration(EventCounter)=indNeg(EventCounter)-indPos(EventCounter);
                            
                            % if there are positive events after this negative then
                            % update the CurrentIndexUp
                            if find(PosEvents>indNeg(EventCounter),1,'first')
                                CurrentIndexUp=PosEvents(find(PosEvents>indNeg(EventCounter),1,'first'));
                            else %% otherwise exit the while loop
                                CurrentIndexUp=size(trace,1);
                            end
                        else
                            if numel(PosEvents)<=(find(PosEvents==CurrentIndexUp)+1)
                                CurrentIndexUp=size(trace,1);
                            else
                                CurrentIndexUp=PosEvents(find(PosEvents==CurrentIndexUp)+1);
                            end
                        end
                    else
                        if numel(PosEvents)<=(find(PosEvents==CurrentIndexUp)+1)
                            CurrentIndexUp=size(trace,1);
                        else
                            CurrentIndexUp=PosEvents(find(PosEvents==CurrentIndexUp)+1);
                        end
                    end
                else
                    
                    % If there are negative events of the right size
                    if  find(trace(CurrentIndexUp:end)<=(trace(CurrentIndexUp)*-EqualityFactor),1,'first')>=MinWindow;
                        EventCounter=EventCounter+1;
                        indNeg(EventCounter)=find(trace(CurrentIndexUp:end)<=(trace(CurrentIndexUp)*-EqualityFactor),1,'first')+offset-1;
                        indPos(EventCounter)=CurrentIndexUp;
                        EventDuration(EventCounter)=indNeg(EventCounter)-indPos(EventCounter);
                        
                        % if there are positive events after this negative then
                        % update the CurrentIndexUp
                        if find(PosEvents>indNeg(EventCounter),1,'first')
                            CurrentIndexUp=PosEvents(find(PosEvents>indNeg(EventCounter),1,'first'));
                            
                        else %% otherwise exit the while loop
                            CurrentIndexUp=size(trace,1);
                        end
                    else
                        
                        
                        if numel(PosEvents)<=(find(PosEvents==CurrentIndexUp)+1)
                            CurrentIndexUp=size(trace,1);
                        else
                            CurrentIndexUp=PosEvents(find(PosEvents==CurrentIndexUp)+1);
                        end
                        
                        
                        
                    end
                end
            end
            
            if  exist('indPos','var')
                Events.SipOns{FileNameCounter+DatabaseOffset,nChannels}= indPos;
                Events.SipOffs{FileNameCounter+DatabaseOffset,nChannels}= indNeg;
                Events.SipDurations{FileNameCounter+DatabaseOffset,nChannels}= EventDuration;
                Events.SipISI{FileNameCounter+DatabaseOffset,nChannels}= indPos(2:end)-indNeg(1:end-1);
                
                
            else
                indNeg=0;
                indPos=0;
                EventDuration=0;
                Events.SipOns{FileNameCounter+DatabaseOffset,nChannels}= indPos;
                Events.SipOffs{FileNameCounter+DatabaseOffset,nChannels}= indNeg;
                Events.SipDurations{FileNameCounter+DatabaseOffset,nChannels}= EventDuration;
                Events.SipISI{FileNameCounter+DatabaseOffset,nChannels}= indPos(2:end)-indNeg(1:end-1);
                
                
            end
        else
            
            indNeg=0;
            indPos=0;
            EventDuration=0;
            Events.SipOns{FileNameCounter+DatabaseOffset,nChannels}= indPos;
            Events.SipOffs{FileNameCounter+DatabaseOffset,nChannels}= indNeg;
            Events.SipDurations{FileNameCounter+DatabaseOffset,nChannels}= EventDuration;
            Events.SipISI{FileNameCounter+DatabaseOffset,nChannels}= indPos(2:end)-indNeg(1:end-1);
        end
        
    end
    %% Activity Bout detection
    %% use Quiroga`s method to find the RMS threshold
    
    clear RMSthrPos RMSPosEvents  F_RMS PosDiffFoundEvents NegDiffFoundEvents IndRMSDiffFoundEvents FoundEvents TrueRMSEvents
    
    for n=1:size(testRMS,2);
        F_RMS=testRMS(:,n);
        RMSPosEvents(1:size(testRMS,1),n)=F_RMS>RMSThresh;
    end
    
    
    for n=1:size(RMSPosEvents,2)
        
        FoundEvents{1,n}=find(RMSPosEvents(:,n));
        PosDiffFoundEvents(:,n)=diff(RMSPosEvents(:,n))>0;
        NegDiffFoundEvents(:,n)=diff(RMSPosEvents(:,n))<0;
        IndRMSDiffFoundEvents{1,n}=find(PosDiffFoundEvents(:,n));
        IndRMSDiffFoundEvents{2,n}=find(NegDiffFoundEvents(:,n));
        IndRMSDiffFoundEvents{3,n}=IndRMSDiffFoundEvents{2,n}-IndRMSDiffFoundEvents{1,n};
    end
    
    %% save in Events structure
    Events.ActivityBoutOns(FileNameCounter+DatabaseOffset,1:size(IndRMSDiffFoundEvents,2))=IndRMSDiffFoundEvents(1,:);
    Events.ActivityBoutOffs(FileNameCounter+DatabaseOffset,1:size(IndRMSDiffFoundEvents,2))=IndRMSDiffFoundEvents(2,1:size(IndRMSDiffFoundEvents,2));
    Events.ActivityBoutDurations(FileNameCounter+DatabaseOffset,1:size(IndRMSDiffFoundEvents,2))=IndRMSDiffFoundEvents(3,1:size(IndRMSDiffFoundEvents,2));
    
    
    
    for x=1:size(Events.SipOns,1)
    for y=1:size(Events.SipOns,2)
        [BOUT_ENDS_AND_BEGINNINGS_indices,BOUT_ENDS_AND_BEGINNINGS]=GET_FEEDING_BURSTS(Events.SipOns{x,y},...
            Events.SipISI{x,y},mode(Events.SipISI{x,y}).*2,3,0);
        
        try
            
            Events.FeedingBurstOns{x,y}=BOUT_ENDS_AND_BEGINNINGS(:,1);
            Events.FeedingBurstOffs{x,y}=BOUT_ENDS_AND_BEGINNINGS(:,2);
            Events.FeedingBurstDurs{x,y}=BOUT_ENDS_AND_BEGINNINGS(:,2)-BOUT_ENDS_AND_BEGINNINGS(:,1);
            Events.FeedingBurstnEvents{x,y}=BOUT_ENDS_AND_BEGINNINGS(:,3);
            Events.FeedingBurstIBI{x,y}=BOUT_ENDS_AND_BEGINNINGS(2:end,1)-BOUT_ENDS_AND_BEGINNINGS(1:end-1,2);
            Events.ActivityBoutIBI{x,y}=Events.ActivityBoutOns{x,y}(2:end)-Events.ActivityBoutOffs{x,y}(1:end-1);

        catch
            
            Events.FeedingBurstOns{x,y}=[];
            Events.FeedingBurstOffs{x,y}=[];
            Events.FeedingBurstDurs{x,y}=[];
            Events.FeedingBurstnEvents{x,y}=[];
            Events.FeedingBurstIBI{x,y}=[];
            Events.ActivityBoutIBI{x,y}=[];

        end
    end
end
    clear IndRMSDiffFoundEvents
    
     
end
cd
save(DataFilename,'Events')
fclose all
